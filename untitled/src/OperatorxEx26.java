public class OperatorxEx26 {
    public static void main(String args[]){
        /* 논리 연산자의 특징은 효율적인 연산을 한다는 것이다. OR 연산 '||'의 경우, 두 피연산자 중 어느 한쪽만 '참'이어도 전체 연산결과가 '참'이므로
        좌측 피연산자가 'ture(참)이면, 우측 피연산자의 값은 평가하지 않는다.
        AND 연산 '&&' 의 경우도 마찬가지로 어느 한쪽만 '거짓(false)'이면 우측 피연산자는 평가하지 않는다.

        그래서 같은 조건식이라도 피연산자의 위치에 따라서 연산속도가 달라질 수 있는 것이다. OR 연산 '||'의 경우에는 연산결과가 '참'일 확률이 높은 피연산자를
        연산자의 왼쪽에 놓아야 더 빠른 연산 결과를 얻을 수 있다. */

        int a = 5;
        int b = 0;

        System.out.printf("a=%d, b=%d%n", a, b);
        System.out.printf("a!=0 || ++b!=0 = %b%n", a!=0 || ++b!=0);
        System.out.printf("a=%d, b=%d%n", a ,b);
        System.out.printf("a==0 && ++b!=0 = %b%n", a==0 && ++b!=0);
        System.out.printf("a=%d, b=%d%n", a, b);
    }
}
/*논리 연산자가 효율적인 연산을 확인하는 결과를 볼 수 있다. 변수 b에 증감 연산자'++'을 사용해서 우측 피연산자가 처리되면, b의 값이 증가 하도록 했다.
그러나 실행결과에서 알 수 있듯이, 두번의 논리 연산후에도 b의 값은 여전히 0인 채로 남아있다. '||(OR)'의 경우는 좌측 피연산자(a!=0)가 참이라서,
그리고 '&&(AND)'의 경우는 좌측 피연산자(a==0)가 거짓이라서 우측 피연산자를 평가하지 않았기 때문이다.
 */